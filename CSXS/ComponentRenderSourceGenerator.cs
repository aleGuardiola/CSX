using CSX.Compilation;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;

namespace CSXS
{
    [Generator]
    public class ComponentRenderSourceGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            var componentReciever = (ComponentsReceiver)context.SyntaxReceiver;

            foreach(var componentFile in componentReciever.ComponentFiles)
            {
                var filePath = componentFile.SyntaxTree.FilePath;
                var xmlFilePath = Path.Combine(Path.GetDirectoryName(filePath), Path.GetFileNameWithoutExtension(filePath));
                var xmlContent = context.AdditionalFiles.First(f => f.Path == xmlFilePath).GetText(context.CancellationToken).ToString();


                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(xmlContent);

                if (xmlDoc.ChildNodes.Count > 1)
                {
                    throw new InvalidOperationException("A component can only have one root component");
                }

                var root = xmlDoc.ChildNodes.Item(0);

                var usings = componentFile.ChildNodes().Where(x => x is UsingDirectiveSyntax).Cast<UsingDirectiveSyntax>();

                var allAssemblies = context.Compilation.SourceModule.ReferencedAssemblySymbols.Concat(new[] { context.Compilation.Assembly }).ToArray();
                var usingNames = usings.Select(x => x.Name.ToString());

                var propTypeResolver = new Func<string, string>(name =>
                {                    
                    foreach(var possibleName in usingNames.Select(x => $"{x}.{name}"))
                    {
                        foreach(var assembly in allAssemblies)
                        {
                            var type = assembly.GetTypeByMetadataName(possibleName);
                            if(type == null)
                            {
                                continue;
                            }

                            var compInterface = type.AllInterfaces.FirstOrDefault(x => x.IsGenericType && x.Name == "IComponent");
                            if(compInterface == null)
                            {
                                continue;
                            }

                            return compInterface.TypeArguments[0].Name;
                        }
                    }

                    throw new InvalidOperationException($"Component {name} connto be found");
                });

                var renderCsharpCode = CsxCompiler.ToCSharp(root, propTypeResolver);
                                
                var @namespace = componentFile.ChildNodes().FirstOrDefault(x => x is NamespaceDeclarationSyntax) as NamespaceDeclarationSyntax;
                var @class = componentFile.ChildNodes().FirstOrDefault(x => x is ClassDeclarationSyntax cds && cds.BaseList != null && cds.BaseList.Types.Any(b => b.Type.ToString().Contains("Component<"))) as ClassDeclarationSyntax;
                if(@class == null)
                {
                    @class = @namespace.ChildNodes().FirstOrDefault(x => x is ClassDeclarationSyntax cds && cds.BaseList != null && cds.BaseList.Types.Any(b => b.Type.ToString().Contains("Component<"))) as ClassDeclarationSyntax;
                }

                var finalCode = @$"
// This code is auto-generated by CSX
#nullable enable
{string.Join("\n", usings.Select(x => x.ToString()))}

namespace {@namespace.Name.ToString()}
{{
    public partial class {@class.Identifier.ValueText}
    {{

        {string.Join("\n", renderCsharpCode.referencesName.Select(x => $"private Element? {x.name}Element;\nprotected {x.type}? {x.name} => {x.name}Element?.Component as {x.type};"))}

        protected override Element Render()
        {{
            return {renderCsharpCode.code};
        }}
    }}
}}

";
                context.AddSource(Path.GetFileNameWithoutExtension(filePath) + ".generated.cs", finalCode);
            }
                   
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            //if (!Debugger.IsAttached)
            //{
            //    Debugger.Launch();
            //}

            // Register a factory that can create our custom syntax receiver
            context.RegisterForSyntaxNotifications(() => new ComponentsReceiver());
        }
    }

    public class ComponentsReceiver : ISyntaxReceiver
    {
        public List<CompilationUnitSyntax> ComponentFiles { get; } = new List<CompilationUnitSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Business logic to decide what we're interested in goes here
            if (syntaxNode is CompilationUnitSyntax cu)
            {
                var @namespace = cu.ChildNodes().FirstOrDefault(x => x is NamespaceDeclarationSyntax);
                if(
                    (@namespace != null && @namespace.ChildNodes().Any(x => x is ClassDeclarationSyntax cds && cds.BaseList != null && cds.BaseList.Types.Any(b => b.Type.ToString().Contains("Component<"))))
                    || cu.ChildNodes().Any(x => x is ClassDeclarationSyntax cds && cds.BaseList != null && cds.BaseList.Types.Any(b => b.Type.ToString().Contains("Component<")))
                    )
                {
                    ComponentFiles.Add(cu);
                }                
            }
        }
    }

}
